import { Injectable, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormlyJsonschema {
    /**
     * @param {?} jsonSchema
     * @return {?}
     */
    toFieldConfig(jsonSchema) {
        return this._toFieldConfig(jsonSchema);
    }
    /**
     * @param {?} jsonSchema
     * @param {?=} key
     * @return {?}
     */
    _toFieldConfig(jsonSchema, key) {
        /** @type {?} */
        const field = Object.assign({}, (key ? { key } : {}), { type: (/** @type {?} */ (jsonSchema.type)), defaultValue: jsonSchema.default, templateOptions: {
                minLength: jsonSchema.minLength,
                maxLength: jsonSchema.maxLength,
                label: jsonSchema.title,
                readonly: jsonSchema.readOnly,
                pattern: jsonSchema.pattern,
                description: jsonSchema.description,
            } });
        if (jsonSchema.enum) {
            if (field.type === 'integer' || field.type === 'number') {
                field.parsers = [Number];
            }
            field.type = 'enum';
            field.templateOptions.options = jsonSchema.enum;
            field.templateOptions.labelProp = item => item;
            field.templateOptions.valueProp = item => item;
        }
        switch (jsonSchema.type) {
            case 'object': {
                field.fieldGroup = [];
                Object.keys(jsonSchema.properties).forEach(p => {
                    /** @type {?} */
                    const child = this._toFieldConfig((/** @type {?} */ (jsonSchema.properties[p])), p);
                    if (Array.isArray(jsonSchema.required) && jsonSchema.required.indexOf(p) !== -1) {
                        child.templateOptions.required = true;
                    }
                    field.fieldGroup.push(child);
                });
                break;
            }
            case 'array': {
                if (!Array.isArray(jsonSchema.items)) {
                    field.fieldArray = this._toFieldConfig((/** @type {?} */ (jsonSchema.items)));
                }
                else {
                    field['_fieldArray'] = [];
                    field.fieldGroup = [];
                    jsonSchema.items.forEach(item => field['_fieldArray'].push(this._toFieldConfig((/** @type {?} */ (item)))));
                    if (jsonSchema.additionalItems) {
                        field['_additionalFieldArray'] = this._toFieldConfig((/** @type {?} */ (jsonSchema.additionalItems)));
                    }
                    Object.defineProperty(field, 'fieldArray', {
                        get: () => {
                            return field['_fieldArray'][field.fieldGroup.length] || field['_additionalFieldArray'];
                        },
                        enumerable: true,
                        configurable: true,
                    });
                }
                break;
            }
        }
        return field;
    }
}
FormlyJsonschema.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ FormlyJsonschema.ngInjectableDef = defineInjectable({ factory: function FormlyJsonschema_Factory() { return new FormlyJsonschema(); }, token: FormlyJsonschema, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FormlyJsonschema };

//# sourceMappingURL=ngx-formly-core-json-schema.js.map